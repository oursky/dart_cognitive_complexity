import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/token.dart';
import 'package:dart_cognitive_complexity/src/cognitive_complexity_visitor_base.dart';

class ComplexityPoint {
  final int complexity;

  ComplexityPoint({
    required this.complexity,
  });
}

class ComplexityIssue {
  final int complexity;
  final Token token;

  ComplexityIssue({
    required this.complexity,
    required this.token,
  });
}

class SecondLevelFunction {
  final AstNode node;
  final AstNode? parent;
  final List<ComplexityPoint> complexityIfThisSecondaryIsTopLevel;
  final List<ComplexityPoint> complexityIfNested;

  SecondLevelFunction({
    required this.node,
    required this.parent,
    required this.complexityIfThisSecondaryIsTopLevel,
    required this.complexityIfNested,
  });
}

class CognitiveComplexityVisitor extends CognitiveComplexityVisitorBase {
  final int threshold;

  int fileComplexity = 0;

  /// Complexity of the current function if it is *not* considered nested to the first level function
  List<ComplexityPoint> complexityIfNotNested = [];

  /// Complexity of the current function if it is considered nested to the first level function
  List<ComplexityPoint> complexityIfNested = [];

  /// Current nesting level (number of enclosing control flow statements and functions)
  int nesting = 0;

  /// Indicator if the current top level function has a structural (generated by control flow statements) complexity
  bool topLevelHasStructuralComplexity = false;

  /// Own (not including nested functions) complexity of the current top function
  List<ComplexityPoint> topLevelOwnComplexity = [];

  /// Nodes that should increase nesting level
  Set<AstNode> nestingNodes = {};

  /// Set of already considered (with already computed complexity) logical expressions
  Set<AstNode> consideredLogicalExpressions = {};

  /// Stack of enclosing functions
  List<AstNode> enclosingFunctions = [];

  List<SecondLevelFunction> secondLevelFunctions = [];

  List<ComplexityIssue> issues = [];

  CognitiveComplexityVisitor({
    required this.threshold,
  });

  @override
  onEnterNode(AstNode node) {
    if (nestingNodes.contains(node)) {
      nesting++;
    }
  }

  @override
  onLeaveNode(AstNode node) {
    if (nestingNodes.contains(node)) {
      nesting--;
      nestingNodes.remove(node);
    }
  }

  @override
  visitConstructorDeclaration(ConstructorDeclaration node) {
    onEnterNode(node);
    onEnterFunction(node);
    visitNode(node);
    onLeaveFunction(node);
    onLeaveNode(node);
  }

  @override
  visitMethodDeclaration(MethodDeclaration node) {
    onEnterNode(node);
    onEnterFunction(node);
    visitNode(node);
    onLeaveFunction(node);
    onLeaveNode(node);
  }

  @override
  visitFunctionExpression(FunctionExpression node) {
    onEnterNode(node);
    onEnterFunction(node);
    visitNode(node);
    onLeaveFunction(node);
    onLeaveNode(node);
  }

  @override
  visitIfStatement(IfStatement node) {
    onEnterNode(node);
    final parent = node.parent;

    // if the current `if` statement is `else if`, do not count it in structural complexity
    if (parent is IfStatement && parent.elseStatement == node) {
      addComplexity();
    } else {
      addStructuralComplexity();
    }
    // always increase nesting level inside `then` statement
    nestingNodes.add(node.thenStatement);

    // if `else` branch is not `else if` then
    // - increase nesting level inside `else` statement
    // - add +1 complexity
    if (node.elseStatement != null && node.elseStatement is! IfStatement) {
      nestingNodes.add(node.elseStatement!);
      addComplexity();
    }

    visitNode(node);
    onLeaveNode(node);
  }

  @override
  visitForStatement(ForStatement node) {
    onEnterNode(node);
    addStructuralComplexity();
    nestingNodes.add(node.body);
    visitNode(node);
    onLeaveNode(node);
  }

  @override
  visitDoStatement(DoStatement node) {
    onEnterNode(node);
    addStructuralComplexity();
    nestingNodes.add(node.body);
    visitNode(node);
    onLeaveNode(node);
  }

  @override
  visitWhileStatement(WhileStatement node) {
    onEnterNode(node);
    addStructuralComplexity();
    nestingNodes.add(node.body);
    visitNode(node);
    onLeaveNode(node);
  }

  @override
  visitSwitchStatement(SwitchStatement node) {
    onEnterNode(node);
    addStructuralComplexity();
    for (final switchCase in node.members) {
      nestingNodes.add(switchCase);
    }
    visitNode(node);
    onLeaveNode(node);
  }

  @override
  visitContinueStatement(ContinueStatement node) {
    onEnterNode(node);
    if (node.label != null) {
      addComplexity();
    }
    visitNode(node);
    onLeaveNode(node);
  }

  @override
  visitBreakStatement(BreakStatement node) {
    onEnterNode(node);
    if (node.label != null) {
      addComplexity();
    }
    visitNode(node);
    onLeaveNode(node);
  }

  @override
  visitCatchClause(CatchClause node) {
    onEnterNode(node);
    addStructuralComplexity();
    nestingNodes.add(node.body);
    visitNode(node);
  }

  @override
  visitBinaryExpression(BinaryExpression node) {
    onEnterNode(node);
    if (node.operator.type == TokenType.AMPERSAND_AMPERSAND ||
        node.operator.type == TokenType.BAR_BAR) {
      visitLogicalExpression(node);
    }
    visitNode(node);
    onLeaveNode(node);
  }

  visitLogicalExpression(BinaryExpression node) {
    if (!consideredLogicalExpressions.contains(node)) {
      final flattenedLogicalExpressions = flattenLogicalExpression(node);
      BinaryExpression? previous;
      for (final current in flattenedLogicalExpressions) {
        if (previous == null ||
            previous.operator.type != current.operator.type) {
          addComplexity();
        }

        previous = current;
      }
    }
  }

  BinaryExpression? findBinaryExperssion(AstNode node) {
    if (node is BinaryExpression) {
      return node;
    }

    if (node is ParenthesizedExpression) {
      return findBinaryExperssion(node.expression);
    }

    return null;
  }

  List<BinaryExpression> flattenLogicalExpression(AstNode node) {
    final maybeBinaryExpression = findBinaryExperssion(node);
    final BinaryExpression expression;
    if (maybeBinaryExpression != null &&
        (maybeBinaryExpression.operator.type == TokenType.AMPERSAND_AMPERSAND ||
            maybeBinaryExpression.operator.type == TokenType.BAR_BAR)) {
      expression = maybeBinaryExpression;
    } else {
      return [];
    }

    consideredLogicalExpressions.add(expression);
    return [
      ...flattenLogicalExpression(expression.leftOperand),
      expression,
      ...flattenLogicalExpression(expression.rightOperand),
    ];
  }

  @override
  visitConditionalExpression(ConditionalExpression node) {
    onEnterNode(node);
    addStructuralComplexity();
    nestingNodes.add(node.thenExpression);
    nestingNodes.add(node.elseExpression);
    visitNode(node);
    onLeaveNode(node);
  }

  onEnterFunction(AstNode node) {
    if (enclosingFunctions.isEmpty) {
      // top level function
      topLevelHasStructuralComplexity = false;
      topLevelOwnComplexity = [];
      secondLevelFunctions = [];
    } else if (enclosingFunctions.length == 1) {
      // second level function
      complexityIfNotNested = [];
      complexityIfNested = [];
    } else {
      nesting++;
      nestingNodes.add(node);
    }
    enclosingFunctions.add(node);
  }

  onLeaveFunction(AstNode node) {
    if (enclosingFunctions.isNotEmpty) {
      enclosingFunctions.removeLast();
    }

    if (enclosingFunctions.isEmpty) {
      // top level function
      if (topLevelHasStructuralComplexity) {
        final totalComplexity = topLevelOwnComplexity;
        for (final secondLevelFunction in secondLevelFunctions) {
          totalComplexity.addAll(secondLevelFunction.complexityIfNested);
        }
        checkFunction(totalComplexity, node);
      } else {
        checkFunction(topLevelOwnComplexity, node);
        for (final secondLevelFunction in secondLevelFunctions) {
          checkFunction(
            secondLevelFunction.complexityIfThisSecondaryIsTopLevel,
            secondLevelFunction.node,
          );
        }
      }
    } else if (enclosingFunctions.length == 1) {
      // second level function
      secondLevelFunctions.add(SecondLevelFunction(
        node: node,
        parent: node.parent,
        complexityIfNested: complexityIfNested,
        complexityIfThisSecondaryIsTopLevel: complexityIfNotNested,
      ));
    } else {
      // complexity of third+ level functions is computed in their parent functions
      // so we never raise an issue for them
    }
  }

  void addComplexity() {
    final complexityPoint = ComplexityPoint(complexity: 1);
    if (enclosingFunctions.isEmpty) {
      // top level scope
      fileComplexity += 1;
    } else if (enclosingFunctions.length == 1) {
      // top level function
      topLevelOwnComplexity.add(complexityPoint);
    } else {
      // second+ level function
      complexityIfNested.add(complexityPoint);
      complexityIfNotNested.add(complexityPoint);
    }
  }

  void addStructuralComplexity() {
    final added = nesting + 1;
    final complexityPoint = ComplexityPoint(complexity: added);
    if (enclosingFunctions.isEmpty) {
      // top level scope
      fileComplexity += added;
    } else if (enclosingFunctions.length == 1) {
      // top level function
      topLevelHasStructuralComplexity = true;
      topLevelOwnComplexity.add(complexityPoint);
    } else {
      // second+ level function
      complexityIfNested.add(ComplexityPoint(
        complexity: added + 1,
      ));
      complexityIfNotNested.add(complexityPoint);
    }
  }

  void checkFunction(List<ComplexityPoint> complexity, AstNode node) {
    final complexityAmount =
        complexity.fold(0, (acc, cur) => acc + cur.complexity);
    fileComplexity += complexityAmount;

    if (complexityAmount > threshold) {
      final maybeMethod = node.thisOrAncestorOfType<MethodDeclaration>();
      if (maybeMethod != null) {
        issues.add(ComplexityIssue(
          complexity: complexityAmount,
          token: maybeMethod.name,
        ));
        return;
      }
      final maybeConstructor =
          node.thisOrAncestorOfType<ConstructorDeclaration>();

      if (maybeConstructor != null) {
        issues.add(ComplexityIssue(
          complexity: complexityAmount,
          token: maybeConstructor.name ?? maybeConstructor.beginToken,
        ));
        return;
      }

      final maybeFunction = node.thisOrAncestorOfType<FunctionDeclaration>();

      if (maybeFunction != null) {
        issues.add(ComplexityIssue(
          complexity: complexityAmount,
          token: maybeFunction.name,
        ));
        return;
      }

      final maybeArrowFunction =
          node.thisOrAncestorOfType<VariableDeclaration>();

      if (maybeArrowFunction != null) {
        issues.add(ComplexityIssue(
          complexity: complexityAmount,
          token: maybeArrowFunction.name,
        ));
        return;
      }

      issues.add(ComplexityIssue(
        complexity: complexityAmount,
        token: node.beginToken,
      ));
    }
  }
}
